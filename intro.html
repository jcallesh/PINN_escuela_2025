<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>intro – PINNs - Escuela 2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-3c73a2198eb6a3db9d40c404f225a8bf.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">PINNs - Escuela 2025</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./intro.html" aria-current="page"> 
<span class="menu-text">PINN Intro</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./colab.html"> 
<span class="menu-text">Colab</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./PINN_notebook.html"> 
<span class="menu-text">Hands-on</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><span class="header-section-number">1</span> <span style="color:#1f77b4;">Introducción</span></a></li>
  <li><a href="#the-good" id="toc-the-good" class="nav-link" data-scroll-target="#the-good"><span class="header-section-number">2</span> <span style="color:#1f77b4;">The good</span></a>
  <ul class="collapse">
  <li><a href="#cómo-funcionan-las-pinns" id="toc-cómo-funcionan-las-pinns" class="nav-link" data-scroll-target="#cómo-funcionan-las-pinns"><span class="header-section-number">2.1</span> Cómo Funcionan las PINNs</a></li>
  <li><a href="#flujo-de-entrenamiento-de-una-pinn" id="toc-flujo-de-entrenamiento-de-una-pinn" class="nav-link" data-scroll-target="#flujo-de-entrenamiento-de-una-pinn"><span class="header-section-number">2.2</span> Flujo de Entrenamiento de una PINN</a></li>
  </ul></li>
  <li><a href="#the-old" id="toc-the-old" class="nav-link" data-scroll-target="#the-old"><span class="header-section-number">3</span> <span style="color:#1f77b4;">The old</span></a></li>
  <li><a href="#the-bad" id="toc-the-bad" class="nav-link" data-scroll-target="#the-bad"><span class="header-section-number">4</span> <span style="color:#1f77b4;">The bad</span></a>
  <ul class="collapse">
  <li><a href="#qué-otras-cosas-podemos-hacer" id="toc-qué-otras-cosas-podemos-hacer" class="nav-link" data-scroll-target="#qué-otras-cosas-podemos-hacer"><span class="header-section-number">4.1</span> ¿Qué otras cosas podemos hacer?</a></li>
  </ul></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><span class="header-section-number">5</span> <span style="color:#1f77b4;">Referencias</span></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><h1 style="color:#F14925; font-size:2.5em; margin-bottom:0.3em;" class="title display-7">
Physics-Informed Neural Networks (PINNs)
</h1></header>




<div style="text-align:center; font-family:sans-serif; line-height:1.6;">

<p style="font-size:1.8em; margin:0.2em 0;">
Juan Calles - <a href="mailto:juan.calles@uv.cl" style="color:inherit; text-decoration:none;">juan.calles@uv.cl</a>
</p>
<p style="font-size:1.5em; font-weight:bold; margin-top:1em;">
Escuela de Física Teórica de Valparaíso
</p>
<p style="font-size:1.3em; margin:0.2em 0;">
3 - 4 - 5 de Diciembre de 2025
</p>
<p style="font-size:1.3em; margin:0.2em 0;">
Facultad de Ciencias y Edificio CIAE
</p>
<p style="font-size:1.3em; margin:0.2em 0;">
Universidad de Valparaíso
</p>
</div>
<section id="introducción" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <span style="color:#1f77b4;">Introducción</span></h1>
<p>Las PINNs fueron introducidas en <a href="https://arxiv.org/abs/1711.10561">Physics Informed Deep Learning</a> como un método que integra datos observacionales y ecuaciones físicas dentro de un mismo modelo. A diferencia de los enfoques numéricos tradicionales, que dependen de discretizaciones específicas para aproximar derivadas, y de los modelos de aprendizaje estándar, que se ajustan únicamente a datos, las PINNs incorporan las ecuaciones que describen el sistema en la función de costo (Loss). Esto permite que la red aprenda soluciones que respetan, de forma aproximada, la estructura diferencial y los datos disponibles del problema. La combinación de información física y datos resulta especialmente útil cuando estos últimos son costosos, irregulares o difíciles de obtener mediante observación o simulación.</p>
</section>
<section id="the-good" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> <span style="color:#1f77b4;">The good</span></h1>
<section id="cómo-funcionan-las-pinns" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="cómo-funcionan-las-pinns"><span class="header-section-number">2.1</span> Cómo Funcionan las PINNs</h2>
<p>En lugar de discretizar el espacio con una malla, una PINN propone que la solución física sea una función continua aproximada por una red neuronal, <span class="math inline">\(u_{\theta}(\mathbf{x}, t)\)</span>, que aproxima la solución de un sistema físico descrito por una ecuación diferencial. Su funcionamiento es una transformación de coordenadas: la red recibe una posición y un tiempo <span class="math inline">\((\mathbf{x}, t)\)</span> y devuelve directamente el valor de la solución en ese punto. La red no almacena la solución, sino que la parametriza. Esto genera un mapeo continuo y diferenciable en todo el dominio, eliminando la dependencia de una malla fija.</p>
<div style="text-align: center;">
<p><img src="pinn.png" alt="Red Neuranal en una PINN" width="60%"></p>
</div>
<blockquote class="blockquote">
<p>Una ventaja técnica relevante proviene del uso de automatic differentiation, que permite evaluar derivadas de cualquier orden de <span class="math inline">\(u_\theta\)</span> de manera exacta dentro del grafo computacional. La Figura ilustra un multi-layer perceptron, en línea discontinua, del cual podemos obtener gradientes ``gratis’’ durante el proceso de entrenamiento. Esto evita introducir esquemas de discretización para las derivadas y facilita incorporar directamente los operadores diferenciales que definen el problema físico.</p>
</blockquote>
<p>Lo que distingue a una PINN no es la arquitectura de la red, sino cómo se “entrena”. En el aprendizaje automático tradicional, la red intenta memorizar y generalizar datos, minimizando el error entre predicción y los dato reales. En una PINN, cambiamos las reglas: le exigimos que ajuste los datos, pero penalizamos cualquier solución que viole las leyes de la física. Básicamente, introducimos explicitamente la Ecuación Diferencial dentro de la función de costo. Esto obliga a la red a encontrar una solución que no solo pase por los datos, sino que obedezca la dinámica del sistema. Esta información “adicional” puede introducirse a manera de ligaduras, leyes de conservación o ecuaciones de movimiento, entre otras formulaciones equivalentes.</p>
<p>Sin pérdida de generalidad, consideremos un sistema descrito por el operador diferenccial no-lineal <span class="math inline">\(\mathcal{N}\)</span> <span class="math display">\[ \mathcal{N}[u(\mathbf{x}, t)] = f(\mathbf{x}, t), \qquad \text{donde} \quad \mathbf{x} \in \Omega \;; \quad t \in [0, T] \,,\]</span></p>
<p>definido en un dominio <span class="math inline">\(\Omega\)</span> y con condiciones de contorno e iniciales dadas por</p>
<p><span class="math display">\[ \rm{I.C:}\; u(\mathbf{x}, 0) = u_0(\mathbf{x}), \quad \mathbf{x} \in \Omega \,.\]</span> <span class="math display">\[ \rm{B.C:}\;\mathcal{B}[u(\mathbf{x}, t)] = g(\mathbf{x}, t), \quad \mathbf{x} \in \partial\Omega \,.\]</span></p>
<p>La innovación crucial de las PINNs consiste en definir una función de pérdida, <span class="math inline">\(\mathcal{L}\)</span>, que no busca únicamente ajustar datos, sino minimizar simultáneamente tres términos:</p>
<ol type="1">
<li><p><strong>Error de Datos (<span class="math inline">\(\mathcal{L}_{data}\)</span>):</strong> Cuantifica la discrepancia con las observaciones reales o simuladas (si existen). Para <span class="math inline">\(N_d\)</span> puntos de observación: <span class="math display">\[\mathcal{L}_{data} = \frac{1}{N_d} \sum_{i=1}^{N_d} |u_{\theta}(\mathbf{x}_i, t_i) - y_i|^2\,.\]</span></p></li>
<li><p><strong>Error Físico o Residuo (<span class="math inline">\(\mathcal{L}_{PDE}\)</span>):</strong> Este término actúa como una penalización para restringir el espacio de las soluciones físicamente aceptables. Definimos el residuo <span class="math inline">\(R_\theta\)</span> como: <span class="math display">\[R_\theta(\mathbf{x}, t) \equiv \mathcal{N}[u_\theta] - f,.\]</span> Evaluamos este residuo en una nube de <span class="math inline">\(N_f\)</span> puntos de colocación <span class="math inline">\((\mathbf{x}_j, t_j)\)</span> distribuidos en el dominio y construyamos la correspondiente función de costo como un error cuadrático medio: <span class="math display">\[\mathcal{L}_{PDE} = \frac{1}{N_f} \sum_{j=1}^{N_f} |R_\theta(\mathbf{x}_j, t_j)|^2,.\]</span> Este procedimiento permite verificar el cumplimiento aproximado de la ecuación sin necesidad de discretizar derivadas.</p></li>
<li><p><strong>Error en las condiciones de contorno e inicial (<span class="math inline">\(\mathcal{L}_{BC}, \mathcal{L}_{IC}\)</span>):</strong> Penalizan las desviaciones en los bordes espaciales y el tiempo inicial: <span class="math display">\[\mathcal{L}_{\rm{B.C.}} , \quad \mathbf{x} \in \partial\Omega,.\]</span> <span class="math display">\[\mathcal{L}_{\rm{I.C.}}, \quad  t=0 ,.\]</span> La forma específica de estos términos depende de las condiciones particulares del problema.</p></li>
</ol>
<p>La función de costo total combina estos términos mediante pesos que regulan su contribución relativa:</p>
<p><span class="math display">\[ \mathcal{L}_{total} = \rm{w}_d\mathcal{L}_{data} + \rm{w}_p\mathcal{L}_{PDE} + \rm{w}_b(\mathcal{L}_{\rm{B.C.}}+\mathcal{L}_{\rm{I.C.}})\,,\]</span></p>
<p>siendo los pesos, <span class="math inline">\((\rm{w}_d, \rm{w}_p, \rm{w}_b)\)</span>, hiperparámetros definidos según las características del problema.</p>
<p>El entrenamiento utiliza algoritmos de gradiente (Adam o L-BFGS) para encontrar los parámetros <span class="math inline">\(\theta\)</span> que minimicen <span class="math inline">\(\mathcal{L}_{total}\)</span>, equilibrando la fidelidad a los datos con la coherencia física del sistema.</p>
</section>
<section id="flujo-de-entrenamiento-de-una-pinn" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="flujo-de-entrenamiento-de-una-pinn"><span class="header-section-number">2.2</span> Flujo de Entrenamiento de una PINN</h2>
El proceso de entrenamiento de una PINN puede visualizarse mediante el diagrama (Imagen generada por <a href="https://deepmind.google/models/gemini-image/pro/">Nano Banana Pro</a>)
<div style="text-align: center;">
<p><img src="Gemini_Generated_Image_eipi2leipi2leipi.png" alt="PINNs esquema" width="80%"></p>
</div>
<p>El proceso puede describirse en cinco pasos esenciales:</p>
<ol type="1">
<li><p>Definir el problema físico. Seleccionar la PDE y las condiciones iniciales/de contorno que se desean modelar.</p></li>
<li><p>Identificar datos disponibles. Incorporar mediciones observacionales y cualquier información parcial del sistema.</p></li>
<li><p>Diseñar la arquitectura. Elegir una red adecuada (MLP, ResNet, CNN, etc.).</p></li>
<li><p><strong>Construir la función de pérdida</strong>. Combinar error de datos y residuo físico obtenido por diferenciación automática.</p></li>
<li><p>Optimizar la red. Entrenar los parámetros mediante métodos como Adam o L-BFGS hasta obtener una solución que satisfaga simultáneamente datos y física.</p></li>
</ol>
</section>
</section>
<section id="the-old" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> <span style="color:#1f77b4;">The old</span></h1>
<p>La resolución de sistemas físicos descritos por ecuaciones diferenciales parciales no-lineales se ha basado históricamente en métodos numéricos como diferencias finitas, elementos finitos y volúmenes finitos, acoplados a esquemas de integración temporal como Runge-Kutta. Estos enfoques son eficaces, pero dependen rígidamente de la discretización del dominio (mallas). En geometrías complejas o alta dimensionalidad, la generación y refinamiento de estas mallas condiciona la estabilidad de la solución y eleva el costo computacional exponencialmente, limitando su capacidad para capturar dinámicas multiescala.</p>
<p>El desafío se agudiza en los problemas inversos, en los cuales la estimación de parámetros internos o la recuperación de campos desconocidos requiere invertir operadores diferenciales que suelen ser mal condicionados. En estos casos, los métodos clásicos dependen de técnicas adicionales de regularización para evitar soluciones espurias.</p>
<p>Las PINNs ofrecen un enfoque alternativo al evitar la necesidad de discretizaciones rígidas. Al trabajar directamente con una representación continua de la solución, permiten evaluar el modelo en cualquier punto del dominio sin depender de una malla fija. En problemas inversos, los parámetros desconocidos pueden incluirse como variables entrenables, lo que permite estimarlos junto con el campo de solución sin modificar la formulación general del método.</p>
<blockquote class="blockquote">
<p>Es importante recalcar que las PINNs no reemplazan de manera universal a los métodos clásicos. Su rendimiento depende del tipo de ecuación, la dimensionalidad del problema y la estrategia de entrenamiento. En ciertos casos, los métodos tradicionales siguen siendo más eficientes o más estables, especialmente cuando se dispone de mallas bien construidas y suficientes datos.</p>
</blockquote>
</section>
<section id="the-bad" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> <span style="color:#1f77b4;">The bad</span></h1>
<p>Las PINNs presentan varias limitaciones que aún restringen su desempeño frente a métodos numéricos tradicionales. En muchos problemas, su precisión es inferior a la alcanzada por esquemas de alto orden, lo que evidencia una brecha sistemática de exactitud. Además, su entrenamiento suele ser inestable debido al sesgo espectral, por el cual la red aprende con rapidez los modos de baja frecuencia pero converge con dificultad hacia componentes de alta frecuencia, comprometiendo la calidad de la solución.</p>
<p>A diferencia de métodos como el de Diferencias Finitas, las PINNs carecen de garantías teóricas de convergencia y de estimaciones rigurosas del error. Esto dificulta evaluar si la solución obtenida es físicamente consistente o si el entrenamiento quedó atrapado en un mínimo local. El costo computacional también es considerable: la evaluación de derivadas mediante automatic differentiation incrementa de forma significativa el tiempo de entrenamiento en comparación con una simulación numérica directa.</p>
<p>Finalmente, las PINNs requieren conocer explícitamente las ecuaciones del sistema. En ausencia de un modelo físico bien establecido, su aplicación estándar resulta limitada, aunque existen extensiones híbridas orientadas al descubrimiento de ecuaciones a partir de datos.</p>
<section id="qué-otras-cosas-podemos-hacer" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="qué-otras-cosas-podemos-hacer"><span class="header-section-number">4.1</span> ¿Qué otras cosas podemos hacer?</h2>
<ul>
<li><p><strong>PINNs Bayesianas</strong> <a href="https://arxiv.org/abs/2003.06097">B-PINNs</a>: Las B-PINNs tratan los pesos de la red neuronal como distribuciones de probabilidad en lugar de valores fijos. Esto permite que la red produzca tanto una predicción como una estimación de incertidumbre (intervalos de confianza), lo cual es crucial para la comparación experimental.</p></li>
<li><p><strong>PINNs Variacionales</strong> <a href="https://arxiv.org/abs/1912.00873">V-PINNs</a>: En lugar de minimizar el residuo de la EDP (forma fuerte), las V-PINNs utilizan la forma débil de la EDP (similar al FEM), integrando las ecuaciones contra funciones de prueba. Esto las hace más robustas frente a datos ruidosos y más capaces de manejar soluciones de baja regularidad.</p></li>
<li><p><strong>Symbolic PINN</strong> <a href="https://arxiv.org/abs/2207.06240">PISN</a>:</p></li>
</ul>
<p>…</p>
</section>
</section>
<section id="referencias" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> <span style="color:#1f77b4;">Referencias</span></h1>
<ul>
<li><a href="https://arxiv.org/pdf/1711.10561">Physics Informed Deep Learning (Part I): Data-driven Solutions of Nonlinear Partial Differential Equations</a></li>
<li><a href="https://arxiv.org/pdf/2201.05624">Scientific Machine Learning through Physics-Informed Neural Networks: Where we are and What’s next</a></li>
<li><a href="https://arxiv.org/abs/2308.08468">AN EXPERT’S GUIDE TO TRAINING PHYSICS-INFORMED NEURAL NETWORKS</a></li>
</ul>
<p>Papers de ML en física:</p>
<ul>
<li><a href="https://ml4physicalsciences.github.io/2025/files/NeurIPS_ML4PS_2025_172.pdf">What Machine Learning Methods is Physics invested in?</a></li>
</ul>
<p>Algunos cursos online recomendados:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=JoFW2uSd3Uo&amp;list=PLMrJAkhIeNNQ0BaKuBKY43k4xMo6NSbBa">Physics Informed Machine Learning: High Level Overview of AI and ML in Science and Engineering - Steve Brunton</a></li>
<li><a href="https://www.youtube.com/@CAMLabETHZurich/courses">CAMLab-youtube</a></li>
</ul>
<p>En el area de Gravitactión y Cosmología:</p>
<ul>
<li><a href="https://ml4physicalsciences.github.io/2025/files/NeurIPS_ML4PS_2025_195.pdf">Symbolic Regression Is All You Need: From Simulations to Scaling Laws in Binary Neutron Star Mergers</a></li>
<li><a href="https://arxiv.org/abs/2508.12032">Cosmology-informed Neural Networks to infer dark energy equation-of-state</a></li>
<li><a href="https://arxiv.org/pdf/2507.11589">EINSTEIN FIELDS: A NEURAL PERSPECTIVE TO COMPUTATIONAL GENERAL RELATIVITY</a></li>
<li><a href="https://arxiv.org/abs/2506.02957">Advancing Cosmological Simulations of Fuzzy Dark Matter with PINN</a></li>
<li><a href="https://arxiv.org/abs/2502.13043">AInstein: Numerical Einstein Metrics via Machine Learning</a></li>
<li><a href="https://arxiv.org/abs/2404.11583">Quasinormal Modes in Modified Gravity using PINN</a></li>
<li><a href="https://arxiv.org/abs/2403.13899">PINNferring the Hubble Function with Uncertainties</a></li>
<li><a href="https://arxiv.org/abs/2402.11343">Solving the Regge-Wheeler and Teukolsky equations: supervised versus unsupervised PINN</a></li>
<li><a href="https://arxiv.org/pdf/2309.07397">Solving Einstein equations using deep learning</a></li>
<li><a href="https://arxiv.org/abs/2305.08448">Gradient-Annihilated PINNs for Solving Riemann Problems: Application to Relativistic Hydrodynamics</a></li>
<li><a href="https://arxiv.org/abs/2212.06103">Solving the Teukolsky equation with PINN</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/jcallesh\.github\.io\/PINN_escuela_2025\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>